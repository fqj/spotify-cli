'use strict';


const fs = require('fs-extra');
const path = require('path');
const _ = require('lodash');

const { logger } = require('./logger');
const { parseJson, getDependenciesFile, getPackageName } = require('./utils');

const COMPOSER_SPECS_PATH = '.';
const SPECS_FILENAME = 'specs.json';
const COMPOSER_FILENAME = 'composer.json'; // if there is not a version file present, this will be the file where the composer info (needed to generate the specs) is set
const DEFAULT_DESCRIPTION_PROPERTY = 'no-desc-available';
const TEMPLATE_TYPE = 'TEMPLATE';
const ADAPTED_KEYS = {
  description: 'desc'
};
const COMPOSER_KEY_VALIDATIONS = {
  name: true,
  description: {
    fallback: 'Autogenerated description. Change it manually'
  },
  preview: {
    fallback: 'cells-preview-default.jpg'
  },
  type: {
    // matches: /^UI$|^CC$|^DM$|^TEMPLATE$/i,
    posibleValues: [ 'UI', 'CC', 'DM', 'TEMPLATE' ],
    fallback: 'UI'
  },
  platforms: {
    // matches: /^(?:(?:\bandroid\b|\bios\b|\bdesktop\b)\s*(?:(?:\,\s*)(?:\bandroid\b|\bios\b|\bdesktop\b))*)$/,
    posibleValues: [ 'android', 'ios', 'desktop' ],
    fallback: [ 'android', 'ios', 'desktop' ]
  },
  family: {
    fallback: 'local'
  }
};

/**
 * Check if:
 * 1. the file component-name.layaout.json exists => returned type is TEMPLATE
 * 2. the component-name ends with '-dm' => returned type is DM. Otherwise, type is UI.
 * @param {String} pathToComponent - path of the component
 * @returns {String} component's infered type.
 */
const inferComponentType = (pathToComponent) => {
  const componentName = path.basename(pathToComponent);
  const templateFilename = path.resolve(pathToComponent, `${componentName}.layout.json`);

  return fs.existsSync(templateFilename) ? 'TEMPLATE' : /^.+-dm$/.test(componentName) ? 'DM' : 'UI';
};


const getFakeComposerObject = (currentPath, file) => {
  const packageName = getPackageName({ root: currentPath });
  const name = (file && file.name) || packageName;
  const description = file && (file.description || file.desc);
  const type = inferComponentType(currentPath);

  return {
      name: name,
      description: description || name,
      preview: 'cells-preview-default.jpg',
      type: type,
      platforms: ['android', 'ios', 'desktop'],
      family: 'local'
  };
};


/**
 * Validates the composer object to be compliant with specific criteria (COMPOSER_KEY_VALIDATIONS) 
 * AND regenerates the object with default values if a specific key doesn't meet that criteria.
 * @param {Object} composerObject - The composer object to validate
 * @returns {Object} Regenerated composer object.
 */
const validateAndFillComposerObject = (composerObject) => {
  const validatedComposerObject = {};

  Object.keys(COMPOSER_KEY_VALIDATIONS).map(
    (key) => {
      const value = composerObject[key];
      const validation = COMPOSER_KEY_VALIDATIONS[key];

      validatedComposerObject[key] = value;
      // If key in composerObject must be present but is 'falsy'
      if (validation) {
        const { fallback } = validation;

        if (!value) {
          if (fallback) {
            logger().warn(`"${key}" key NOT present in '${COMPOSER_FILENAME}'. Set to '${fallback}'`);
            validatedComposerObject[key] = fallback;
          } else {
            throw new Error(`"${key}" key NOT present in '${COMPOSER_FILENAME}'. You must set it manually`);
          }
        } else {
          const { posibleValues } = validation;
          const valuesArray = Array.isArray(value) ? value : [value];
          if (posibleValues && !valuesArray.every((value) => posibleValues.includes(value)) ) {
            logger().warn(`'"${key}": ${value}' does not match any value of '${posibleValues}'. Set to '${fallback}'`);
            validatedComposerObject[key] = fallback;
          }
        }
      }
    }
  );

  return validatedComposerObject;
};

/**
 * This function validates the composer key of version file or the values of composer file. Default values are added/overrided if needed.
 * 
 * @returns {Object} The composer key generated/validated.
 */
const generateComposerObject = (currentPath) => {
  // const packageFile = getDependenciesFile(currentPath);
  let file;
  let filePath;

  try {
  // if (packageFile) {
  //   filePath = getDependenciesFile(currentPath, true);
  //   file = Object.prototype.hasOwnProperty.call(packageFile, 'composer') ? validateAndFillComposerObject(packageFile.composer) : getFakeComposerObject(currentPath, packageFile);
  // } else {
    filePath = path.join(currentPath, COMPOSER_FILENAME);

    if (fs.existsSync(filePath)) {
      file = validateAndFillComposerObject(parseJson(filePath));
    } else {
      file = getFakeComposerObject(currentPath);
      logger().warn(`Generated ${filePath} with value:\n${JSON.stringify(file, null, 4)}`);
    }
  // }
    fs.writeJsonSync(filePath, file, {spaces: 4});
  } catch (error) {
    logger().error(`Error generating composer.json file: ${error}`);
  }

  return file;
};

// /**
// * Check if it is a composer component and return composer and descriptor metadata
// * @returns {Object|Undefined} { annotationComposer, annotationDescriptor }
// */
// const getAnnotationComposer = (root) => {
//   return generateComposerObject(root);
// };

/**
* Returns descriptor agrouped metadata
* @returns {Object|Undefined} { annotationDescriptor }
*/
const getAnnotationDescriptor = (parameters, specs) => {
  const annotationDescriptor = _.get(parameters, 'analyzer.elements[0]');
  const agroupMetadata = agroupDescriptorMetadata(annotationDescriptor);

  return Object.assign(specs || {}, agroupMetadata);
};

/**
 * Normalize metadata descriptor.json
 *
 * @param {Object} { annotationDescriptor }
 * @returns {Object}
 */
const agroupDescriptorMetadata = (annotationDescriptor) => {
  const componentProperties = annotationDescriptor.properties;
  const componentMethods = annotationDescriptor.methods;
  const componentEvent = annotationDescriptor.events;

  // Check if it is a composer component
  const _isProperty = (element) => {
    const types = [
      'Boolean',
      'String',
      'Number',
      'Object',
      'Array'
    ];
    return types.includes(_.capitalize(element.type)) && element.privacy === 'public' && element.metadata.polymer.readOnly !== true;
  };

  // get public properties, only privacy public and not readOnly (It includes computed properties)
  const getPublicProperties = (elements) => elements.filter(_isProperty);

  const _isMethod = (element) => element.privacy === 'public';
  // get public methods, only privacy public
  const getPublicMethods = (elements) => elements.filter(_isMethod);

  const actionsInProperties = getPublicProperties(componentProperties);
  const actionsInMethods = getPublicMethods(componentMethods);
  // Concat all actions In
  const actionsIn = actionsInMethods.concat(actionsInProperties);
  // Actions Out, events in descriptor.json
  const actionsOut = componentEvent;

  // build and normalize Properties
  const _buildProperties = (actionsInProperties) => {
    return actionsInProperties.map(({ name, description, type, defaultValue }) => {
      const capitalizeType = _.capitalize(type);
      const actionsInProperties = {
        name: name,
        desc: description && description.trim() ? description : DEFAULT_DESCRIPTION_PROPERTY,
        type: capitalizeType === 'String' ? 'TEXT' : capitalizeType
      };

      if (defaultValue) {
        actionsInProperties.default = JSON.parse(defaultValue);
      }

      return actionsInProperties;
    });
  };

  const camelCaseToDash = (myStr) => myStr.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

  // build and normalize actions
  const _buildCellsConnections = (actionsIn, actionsOut) => {
    const cellsConnections = {};

    cellsConnections.in = {};
    cellsConnections.out = {};

    // actions in
    actionsIn.forEach(({name, description}) => {
      const action = {
        name: name,
        desc: description && description.trim() ? description : DEFAULT_DESCRIPTION_PROPERTY
      };
      cellsConnections.in[name] = action;
    });

    // actions out
    actionsOut.forEach(({name, description}) => {
      const action = {
        name: camelCaseToDash(name),
        desc: description && description.trim() ? description : DEFAULT_DESCRIPTION_PROPERTY,
      };
      cellsConnections.out[name] = action;
    });

    return cellsConnections;
  };

  // format all values
  const specsDescriptor = {
    properties: _buildProperties(actionsInProperties),
    cellsConnections: _buildCellsConnections(actionsIn, actionsOut)
  };

  return specsDescriptor;
};


const adaptComposerKeySpecs = (specs) => {
  Object.keys(ADAPTED_KEYS).forEach(key => {
    let regex = new RegExp(`\\"${key}\\":`, 'g');

    specs = JSON.parse(
      JSON.stringify(specs).replace(regex, `"${ADAPTED_KEYS[key]}":`)
    );
  });

  return specs;
}

/**
 * Write the specs.json file at 'path'.
 * @param {Object} specs 
 */
const writeSpecsFile = (componentPath, specs) => {
  const specsPath = path.join(componentPath, SPECS_FILENAME);
  try {
    fs.writeJsonSync(specsPath, specs, {spaces: 4});
    logger().info(`specs.json file has been generated at ${specsPath}`);
  } catch(e) {
    logger().error(`Error generating specs.json file: ${e}`);
  }
};

/**
 * Check if the component who has the input specs is a template. It means that the type key should be equals to 'template' (ignoring case).
 * @param {Object} specs 
 */
const isTemplate = (specs) => specs && specs.type && specs.type.toUpperCase() === TEMPLATE_TYPE;

/**
 * Append the layout key with the layout content file to the specs object if proceed.
 * @param {String} root: Path of the current component
 * @returns {Function} Function to add the layout json content to the specs if proceed.
 *  @param {Object} specs.
 *  @returns {Object} Updated specs. 
 */
const layoutTemplateSpecs = (root, specs) => {
  let layout = {};

  if (isTemplate(specs)) {
    let layoutFilename = path.resolve(root, `${path.basename(root)}.layout.json`);
    if (fs.existsSync(layoutFilename)) {
      const layoutJSON = parseJson(layoutFilename);
      layout.layout = layoutJSON;
    } else {
      throw new Error(`${specs.name} is a template, but the layout file ${layoutFilename} does not exist`);
    }
  }

  return Object.assign(specs || {}, layout);
};

/**
 * Generate specs.json file for the component at 'componentPath' that uses Composer.
 * It will run a custom version of the polymer analyzer and will merge that info with the composer.json at 'path'
 * to generate the specs.json. 
 * 
 * @param {string} componentPath - The path where the component is located
 */
const generateSpecs = (componentPath) => (parameters) => {
  // Get all metadata ({bower.json} {descriptor.json})
  // { annotationComposer, annotationDescriptor }
  
  const componentFullPath = path.resolve(componentPath);
  let specs = generateComposerObject(componentFullPath);
  logger().debug(`Generated Composer Object: ${JSON.stringify(specs, null, 4)}`);
  specs = adaptComposerKeySpecs(specs);
  logger().debug(`Adapted Composer Object: ${JSON.stringify(specs, null, 4)}`);
  specs = getAnnotationDescriptor(parameters, specs);
  logger().debug(`Annotated Composer Object: ${JSON.stringify(specs, null, 4)}`);
  specs = layoutTemplateSpecs(componentFullPath, specs);
  logger().debug(`Full Composer Object: ${JSON.stringify(specs, null, 4)}`);
  writeSpecsFile(componentFullPath, specs);
  return parameters;
};

module.exports = {
    generateSpecs
};